-----------------------------------------------------------------
import java.util.Scanner;
class BinaryTree {

    public BinaryTree() {

    }

    private static class Node {
        int value;
        Node left;
        Node right;

        public Node(int value) {
        this.value = value;
        }
    }

    private Node root;

    // insert elements
    public void populate(Scanner scanner) {
        System.out.println("Enter the root Node: ");
        int value = scanner.nextInt();
        root = new Node(value);
        populate(scanner, root);
    }

    private void populate(Scanner scanner, Node node) {
        System.out.println("Do you want to enter left of " + node.value);
        boolean left = scanner.nextBoolean();
        if (left) {
        System.out.println("Enter the value of the left of " + node.value);
        int value = scanner.nextInt();
        node.left = new Node(value);
        populate(scanner, node.left);
        }

        System.out.println("Do you want to enter right of " + node.value);
        boolean right = scanner.nextBoolean();
        if (right) {
        System.out.println("Enter the value of the right of " + node.value);
        int value = scanner.nextInt();
        node.right = new Node(value);
        populate(scanner, node.right);
        }

    }

    public void display() {
        display(this.root, "");
    }

    private void display(Node node, String indent) {
        if (node == null) {
        return;
        }
        System.out.println(indent + node.value);
        display(node.left, indent + "\t");
        display(node.right, indent + "\t");
    }

    public void prettyDisplay() {
        prettyDisplay(root, 0);
    }

    private void prettyDisplay(Node node, int level) {
        if (node == null) {
        return;
        }

        prettyDisplay(node.right, level + 1);

        if (level != 0) {
        for (int i = 0; i < level - 1; i++) {
            System.out.print("|\t\t");
        }
        System.out.println("|------->" + node.value);
        } else {
        System.out.println(node.value);
        }
        prettyDisplay(node.left, level + 1);
    }

    public void preOrder() { // Left -> Root -> Right
        preOrder(root);
    }

    private void preOrder(Node node) {
        if (node == null) {
        return;
        }
        System.out.print(node.value + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    public void inOrder() { // Root -> Left -> Right


        inOrder(root);
    }

    private void inOrder(Node node) {
        if (node == null) {
        return;
        }
        inOrder(node.left);
        System.out.print(node.value + " ");
        inOrder(node.right);
    }

    public void postOrder() { // Left -> Right -> Root
        postOrder(root);
    }

    private void postOrder(Node node) {
        if (node == null) {
        return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.print(node.value + " ");
    }
}
-----------------------------------------------------------------
class BST {
  public class Node {
    private int value;
    private Node left;
    private Node right;
    private int height;

    public Node(int value) {
      this.value = value;
    }

    public int getValue() {
      return value;
    }
  }

  private Node root;

  public BST() {

  }

  public int height(Node node) {
    if (node == null) {
      return -1;
    }
    return node.height;
  }

  public boolean isEmpty() {
    return root == null;
  }

  public void insert(int value) {
    root = insert(value, root);
  }

  private Node insert(int value, Node node) {
    if (node == null) {
      node = new Node(value);
      return node;
    }

    if (value < node.value) {
      node.left = insert(value, node.left);
    }

    if (value > node.value) {
      node.right = insert(value, node.right);
    }

    node.height = Math.max(height(node.left), height(node.right)) + 1;
    return node;
  }

  public void populate(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
      this.insert(nums[i]);
    }
  }

  public void populatedSorted(int[] nums) {
    populatedSorted(nums, 0, nums.length);
  }

  private void populatedSorted(int[] nums, int start, int end) {
    if (start >= end) {
      return;
    }

    int mid = (start + end) / 2;

    this.insert(nums[mid]);
    populatedSorted(nums, start, mid);
    populatedSorted(nums, mid + 1, end);
  }

  public boolean balanced() {
    return balanced(root);
  }

  private boolean balanced(Node node) {
    if (node == null) {
      return true;
    }
    return Math.abs(height(node.left) - height(node.right)) <= 1 && balanced(node.left) && balanced(node.right);
  }

  public void display() {
    display(this.root, "Root Node: ");
  }

  private void display(Node node, String details) {
    if (node == null) {
      return;
    }
    System.out.println(details + node.value);
    display(node.left, "Left child of " + node.value + " : ");
    display(node.right, "Right child of " + node.value + " : ");
  }

}
-----------------------------------------------------------------
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    // Scanner scanner = new Scanner(System.in);
    // BinaryTree tree = new BinaryTree();
    // tree.populate(scanner);
    // tree.prettyDisplay();

    BST tree = new BST();
    int[] nums = { 5, 2, 7, 1, 4, 6, 9, 8, 3, 10 };
    tree.populate(nums);
    tree.display();
  }
}
-----------------------------------------------------------------
class BFS {
  public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();

    if (root == null) {
      return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
      int levelSize = queue.size();
      List<Integer> currentLevel = new ArrayList<>(levelSize);
      for (int i=0; i < levelSize; i++) {
        TreeNode currentNode = queue.poll();
        currentLevel.add(currentNode.val);
        if (currentNode.left != null) {
          queue.offer(currentNode.left);
        }
        if (currentNode.right != null) {
          queue.offer(currentNode.right);
        }
      }
      result.add(currentLevel);
    }
    return result;
  }

  public List<Integer> rightSideView(TreeNode root) {
    List<Integer> result = new ArrayList<>();

    if (root == null) {
      return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
      int levelSize = queue.size();

      for (int i=0; i < levelSize; i++) {
        TreeNode currentNode = queue.poll();

        if (i == levelSize - 1) {
          result.add(currentNode.val);
        }
        
        if (currentNode.left != null) {
          queue.offer(currentNode.left);
        }
        if (currentNode.right != null) {
          queue.offer(currentNode.right);
        }
      }
    }
    return result;
  }

  public List<Double> averageOfLevels(TreeNode root) {
    List<Double> result = new ArrayList<>();

    if (root == null) {
      return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
      int levelSize = queue.size();
      double averageLevel = 0;
      for (int i=0; i < levelSize; i++) {
        TreeNode currentNode = queue.poll();
        averageLevel += currentNode.val;
        if (currentNode.left != null) {
          queue.offer(currentNode.left);
        }
        if (currentNode.right != null) {
          queue.offer(currentNode.right);
        }
      }
        averageLevel = averageLevel / levelSize;
        result.add(averageLevel);
    }
    return result;
  }

  public TreeNode findSuccessor(TreeNode root, int key){
    if (root == null) {
      return null;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
      int levelSize = queue.size();
        TreeNode currentNode = queue.poll();
        if (currentNode.left != null) {
          queue.offer(currentNode.left);
        }
        if (currentNode.right != null) {
          queue.offer(currentNode.right);
        }
        if (currentNode.val = key) {
          break;
        }
    }
    return queue.peek(); 
  }

  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();

    if (root == null) {
      return result;
    }

    Deque<TreeNode> queue = new LinkedList<>();
    queue.add(root);

    boolean reverse = false;
    
    while (!queue.isEmpty()) {
      int levelSize = queue.size();
      List<Integer> currentLevel = new ArrayList<>(levelSize);
      for (int i=0; i < levelSize; i++) {
        if (!reverse) {
          TreeNode currentNode = queue.pollFirst();
          currentLevel.add(currentNode.val);
          if (currentNode.left != null) {
            queue.addLast(currentNode.left);
          }
          if (currentNode.right != null) {
            queue.addLast(currentNode.right);
          }
        } else {
          TreeNode currentNode = queue.pollLast();
          currentLevel.add(currentNode.val);
          if (currentNode.right != null) {
            queue.addFirst(currentNode.right);
          }
          if (currentNode.left != null) {
            queue.addFirst(currentNode.left);
          }
        }
      }
      reverse = !reverse;
      result.add(currentLevel);
    }
    return result;
  }


  public Node connect(Node root) {
    if (root == null){
      return null;
    }

    Node leftMost = root;

    while (leftMost.left != null) {
      Node current = leftMost;
      while(current != null) {
        current.left.next = current.right;
        if(current.next != null) {
          current.right.next = current.next.left;
        }
        current = current.next;
      }
      leftMost = leftMost.left;
    }
    return root;
  }


  public boolean isCousins(TreeNode root, int x, int y) {
    TreeNode xx = findNode(root, x);
    TreeNode yy = findNode(root, y);

    return (
      (level(root, xx, 0) == level(root, yy, 0)) && (!isSibling(root, xx, yy))
    );
  }

  TreeNode findNode(TreeNode node, int x) {
    if (node == null) {
      return null;
    }
    if (node.val == x) {
      return node;
    }
    TreeNode n = findNode(node.left, x);
    if (n != null) {
      return n;
    }
    return findNode(node.right, x);
  }

  boolean isSibling (TreeNode node, TreeNode x, TreeNode y) {
    if (node == null) {
      return false;
    }

    return (
      (node.left == x && node.right == y) || (node.left == y && node.right == x)
      || isSibling(node.left, x, y) || isSibling(node.right, x, y)
    );
  }

  int level (TreeNode node, TreeNode x, int lev) {
    if(node == null) {
      return 0;
    }

    if(node == x) {
      return lev;
    }

    int l = level(node.left, x, lev+1);
    if (l != 0) {
      return l;
    }
    return level(node.right, x, lev+1);
  }

  public boolean isSymmetric(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root.left);
    queue.add(root.right);

    while(!queue.isEmpty()) {
      TreeNode left = queue.poll();
      TreeNode right = queue.poll();

      if(left == null && right == null) {
        continue;
      }
      
      if(left == null || right == null) {
        return false;;
      }

      if (left.val != right.val) {
        return false;
      }

      queue.add(left.left);
      queue.add(right.right);
      queue.add(left.right);
      queue.add(right.left);
      
    }
    return true;
  }

  
  
}
-----------------------------------------------------------------
class DFS {

  // dfs using stack
  void dfsStack(Node node) {
    if(node == null) {
      return;
    }
    Stack<Node> stack = new Stack<>();
    stack.push(node);

    while(!stack.isEmpty()) {
      Node removed = stack.pop();
      System.out.print(removed.val + " ");
      if(removed.right != null) {
        stack.push(removed.right);
      }
      if(removed.left != null) {
        stack.push(removed.left);
      }
    }
  }

  int diameter = 0;
  public int diameterOfBinaryTree(TreeNode root) {
    height(root);
    return diameter-1;
  }
  int height(TreeNode node) {
    if(node == null) {
      return 0;
    }

    int leftHeight = height(node.left);
    int rightHeight = height(node.right);

    int dia = leftHeight + rightHeight + 1;
    diameter = Math.max(diameter, dia);

    return Math.max(leftHeight, rightHeight) + 1;
    
  }


  public TreeNode invertTree(TreeNode root) {
    if (root == null) {
      return null;
    }

    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    root.left = right;
    root.right = left;

    return root;
  }

  public void flatten(TreeNode root) {
    TreeNode current = root;
    while (current != null) {
      if (current.left != null) {
        TreeNode temp = current.left;
        while(temp.right != null) {
          temp = temp.right;
        }

        temp.right = current.right;
        current.right = current.left;
        current.left= null;
      }
      current = current.right;
    }
    
  }

  public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
  }
  public boolean helper(TreeNode node, Integer low, Integer high) {
    if (node == null) {
      return true;
    }

    if (low != null && node.val <= low) {
      return false;
    }

    if(high != null && node.val >= high) {
      return false;
    }

    boolean leftTree = helper(node.left, low, node.val);
    boolean rightTree = helper(node.right, node.val, high);

    return leftTree && rightTree;
    
  }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      if (root == null) {
        return null;
      }

      if (root == p || root == q) {
        return root;
      }

      TreeNode left = lowestCommonAncestor(root.left, p, q);
      TreeNode right = lowestCommonAncestor(root.right, p, q);

      if (left != null && right != null) {
        return root;
      }

      return left == null ? right : left;

    }
  
    int count = 0;
    public int kthSmallest(TreeNode root, int k) {
        return helper(root, k).val;
    }
    public TreeNode helper(TreeNode root, int k) {
      if (root == null) {
        return null;
      }
  
      TreeNode left = helper(root.left, k);

      if (left != null) {
        return left;
      }

      count++;

      if(count == k) {
        return root;
      }

      return helper(root.right, k);
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {

      if (preorder.length == 0) {
        return null;
      }

      int r = pre[0];
      int index = 0;

      for(int i=0; i<inorder.length; i++) {
        if(inorder[i] == r) {
          index = i;
        }
      }

      Node node = new Node(r);

      node.left = buildTree(Arrays.copyOfRange(preorder, 1, index + 1), Arrays.copyOfRange(inorder, 0, index));
      node.right = buildTree(Arrays.copyOfRange(preorder, index + 1, preorder.length), Arrays.copyOfRange(inorder, index + 1, inorder.length));

      return node;
        
    }
  
}
-----------------------------------------------------------------
class PathSum {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) {
      return false;
    }
    if (root.val == sum && root.left == null && root.right == null) {
      return true;
    }
    return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);
  }

  public int sumNumbers(TreeNode root) {
    return helper(root, 0);
  }
  int helper(TreeNode node, int sum) {
    if(node == null) {
      return 0;
    }
    sum = sum * 10 + node.val;
    if (node.left == null && node.right == null) {
      return sum;
    }
    return helper(node.left, sum) + helper(node.right, sum);
  }

  int ans = Integer.MIN_VALUE;
  public int maxPathSum(TreeNode root) {
      helper(root);
      return ans;
  }
  int helper(TreeNode node) {
    if(node == null) {
      return 0;
    }

    int left = helper(node.left);
    int right = helper(node.right);

    left = Math.max(0, left);
    right = Math.max(0, right);

    int pathSum = left + right + node.val;

    ans = Math.max(ans, pathSum);

    return Math.max(left, right) + node.val;
  }

  boolean findPath(Node node, int[] arr) {
    if (node == null) {
      return arr.length == 0;
    }
    return helper(node, arr, 0);
  }
  boolean helper(Node node, int[] arr, int index) {
    if(node == null) {
      return false;
    }
    if(index >= arr.length || node.val != arr[index]) {
      return false;
    }
    if(node.left == null && node.right == null && index = arr.length - 1) {
      return true;
    } 
    return helper(node.left, arr, index + 1) || helper(node.right, arr, index + 1);
  }

  int countPaths(Node node, int sum) {
    List<Integer> path = new ArrayList<>();
    return helper(node, sum, path);
  }
  int helper(Node node, int sum, List<Integer> path) {
    if(node == null) {
      return 0;
    }

    path.add(node.val);
    int count = 0;
    int s = 0;
    // how many paths I can make
    ListIterator<Integer> itr = path.listIterator(path.size());
    while (itr.hashPrevious()) {
      s += itr.previous();

      if (s == sum) {
        count++;
      }
    }

    count += helper(node.left, s, path) + helper(node.right, sum, path);

    // backtrack
    path.remove(path.size() - 1);
    return count;
    
  }

  // put in a list
  List<List<Integer>> findPaths(Node node, int sum) {
    List<List<Integer>> paths = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    helper(node, sum, path);
    return paths;
  }
  void helper(Node node, int sum, List<Integer> path, List<List<Integer>> paths) {
    if(node == null) {
      return 0;
    }

    path.add(node.val);

    if (node.val == sum && node.left == null && node.right == null) {
      paths.add(new ArrayList<>(path));
    } else {
      helper(node.left, sum-node.val, path, paths);
      helper(node.right, sum-node.val, path, paths);
    }

    // backtrack
    path.remove(path.size() - 1);    
  }  
}
-----------------------------------------------------------------
// https://leetcode.com/problems/serialize-and-deserialize-binary-tree/

class SD {
  public List<String> serialize(Node node) {
    List<String> list = new ArrayList<>();
    helper(node, list);
    return list;
  }
  void helper(Node node, List<String> list) {
    if (node == null) {
      list.add("null");
      return;
    }  
    
    list.add(String.valueOf(node.val));

    helper(node.left, list);
    helper(node.right, list);
  }

  Node deserialize(List<String> list) {
    Collections.reverse(list);
    Node node = helper2(list);
    return node;
  }
  Node helper(List<String> list) {
    String val = list.remove(list.size() - 1);

    if (val.charAt(0) == 'n') {
      return null;
    }
    
    Node node = new Node(Integer.parseInt(val));

    node.left = helper2(list);
    node.right = helper2(list);

    return node;
  }
}
-----------------------------------------------------------------
important, please revise
class FenwickTree{
    private int[] fenArr;
    public FenwickTree(int[] arr){
        this.fenArr = new int[arr.length + 1];
        for (int i = 1; i<arr.length+1; i++){
            update(i, arr[i-1]);
        }
    }
    public void update(int i, int add){
        while(i < fenArr.length){
            fenArr[i] += add;
            i += (i & (-i)); // 2's compliment
        }
    }
    public int sum(int i){
        int s = 0;
        while(i>0){
            s+=fenArr[i];
            i = i - (i&(-i));
        }
        return s;
    }
    public int rangeSum(int l, int r){
        return sum(r) - sum(l-1);
    }
    public static void main(String[] args) {
        int[] arr = {1,0,2,1,1,3,0,4,2,5,2,2,3,1,0,2};
        FenwickTree tree = new FenwickTree(arr);
        System.out.println(tree.rangeSum(0, 3));
    }
}
-----------------------------------------------------------------
important, please revise - SQRT decomposition
import java.util.Arrays;

class Main {
  public static void main(String[] args) {
    int[] arr = {1, 3, 5, 2, 7, 6, 3, 1, 4, 8};
    int n = arr.length;

    // build a blocks array
    int sqrt = (int) Math.sqrt(n);

    int block_id = -1;
    
    int[] blocks = new int[sqrt + 1];

    for(int i = 0; i < n; i++) {
      // new block is starting
      if(i % sqrt == 0) {
        block_id++;
      }
      blocks[block_id] += arr[i];
    }

    System.out.println(query(blocks, arr, 2, 7, 3));
  }

    public static int query(int[] blocks, int[] arr, int l, int r, int sqrt) {
      int ans = 0;

      // left part
      while(l%sqrt != 0 && l<r && l!=0) {
        ans += arr[l];
        l++;
      }

      // midle part
      while(l + sqrt <= r) {
        ans += blocks[l/sqrt];
        l += sqrt;
      }

      // right part
      while(l <= r) {
        ans += arr[l];
        l++;
      }

      return ans;
    }

    public void update(int[] blocks, int[] arr, int i, int val, int sqrt) {
      int block_id = i / sqrt;
      blocks[block_id] += (val - arr[i]);
      arr[i] = val;
    }
    
  }
-----------------------------------------------------------------
class AVL {

  public static void main(String[] args) {
    AVL tree = new AVL();

    for(int i=0; i < 1000; i++) {
      tree.insert(i);
    }

    System.out.println(tree.height());
  }

  public class Node {
    private int value;
    private Node left;
    private Node right;
    private int height;

    public Node(int value) {
      this.value = value;
    }

    public int getValue() {
      return value;
    }
  }

  private Node root;

  public AVL() {

  }

  public int height() {
    return height(root);
  }
  private int height(Node node) {
    if (node == null) {
      return -1;
    }
    return node.height;
  }
  
  public void insert(int value) {
    root = insert(value, root);
  }

  private Node insert(int value, Node node) {
    if (node == null) {
      node = new Node(value);
      return node;
    }

    if (value < node.value) {
      node.left = insert(value, node.left);
    }

    if (value > node.value) {
      node.right = insert(value, node.right);
    }

    node.height = Math.max(height(node.left), height(node.right)) + 1;
    return rotate(node);
  }

  private Node rotate(Node node) {
    if (height(node.left) - height(node.right) > 1) {
      // left heavy
      if(height(node.left.left) - height(node.left.right) > 0) {
        // left left case
        return rightRotate(node);
      }
      if(height(node.left.left) - height(node.left.right) < 0) {
        // left right case
        node.left = leftRotate(node.left);
        return rightRotate(node);
      }
    }

    if (height(node.left) - height(node.right) < -1) {
      // right heavy
      if(height(node.right.left) - height(node.right.right) < 0) {
        // right right case
        return leftRotate(node);
      }
      if(height(node.right.left) - height(node.right.right) > 0) {
        // left right case
        node.right = rightRotate(node.right);
        return leftRotate(node);
      }
    }

    return node;
  }

  public Node rightRotate(Node p) {
    Node c = p.left;
    Node t = c.right;

    c.right = p;
    p.left = t;
    
    p.height = Math.max(height(p.left), height(p.right) + 1);
    c.height = Math.max(height(c.left), height(c.right) + 1);

    return c;
  }

  public Node leftRotate(Node c) {
    Node p = c.right;
    Node t = p.left;

    p.left = c;
    c.right = t;
    
    p.height = Math.max(height(p.left), height(p.right) + 1);
    c.height = Math.max(height(c.left), height(c.right) + 1);

    return p;
  }

  public void populate(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
      this.insert(nums[i]);
    }
  }

  public void populatedSorted(int[] nums) {
    populatedSorted(nums, 0, nums.length);
  }

  private void populatedSorted(int[] nums, int start, int end) {
    if (start >= end) {
      return;
    }

    int mid = (start + end) / 2;

    this.insert(nums[mid]);
    populatedSorted(nums, start, mid);
    populatedSorted(nums, mid + 1, end);
  }

  public void display() {
    display(this.root, "Root Node: ");
  }

  private void display(Node node, String details) {
    if (node == null) {
      return;
    }
    System.out.println(details + node.value);
    display(node.left, "Left child of " + node.value + " : ");
    display(node.right, "Right child of " + node.value + " : ");
  }

  public boolean isEmpty() {
    return root == null;
  }

  public boolean balanced() {
    return balanced(root);
  }

  private boolean balanced(Node node) {
    if (node == null) {
      return true;
    }
    return Math.abs(height(node.left) - height(node.right)) <= 1 && balanced(node.left) && balanced(node.right);
  }

}
-----------------------------------------------------------------
class SegmentTree {

  public static void main(String[] args) {
    int[] arr = {3, 8, 6, 7, -2, -8, 4, 9};
    SegmentTree tree = new SegmentTree(arr);
    // tree.display();

    System.out.println(tree.query(1, 6));
  }

  private static class Node {
    int data;
    int startInterval;
    int endInterval;
    Node left;
    Node right;

    public Node (int startInterval, int endInterval) {
      this.startInterval = startInterval;
      this.endInterval = endInterval;
    }
  }

  Node root;

  public SegmentTree(int[] arr) {
    // create a tree using this array
    this.root = constructTree(arr, 0, arr.length - 1);
  }

  private Node constructTree(int[] arr, int start, int end) {
    if(start == end) {
      // leaf node
      Node leaf = new Node(start, end);
      leaf.data = arr[start];
      return leaf;
    }

    // create new node with index you are at
    Node node = new Node(start, end);
    
    int mid = (start + end) / 2;

    node.left = this.constructTree(arr, start, mid);
    node.right = this.constructTree(arr, mid + 1, end);

    node.data = node.left.data + node.right.data;
    return node;
  }

  public void display() {
    display(this.root);
  }
  private void display(Node node) {
    String str = "";

    if(node.left != null) {
      str = str + "Interval=[" + node.left.startInterval + "-" + node.left.endInterval + "] and data: " + node.left.data + " => "; 
    } else {
      str = str + "No left child";
    }

    // for current node
    str = str + "Interval=[" + node.startInterval + "-" + node.endInterval + "] and data: " + node.data + " <= "; 
    
    if(node.right != null) {
      str = str + "Interval=[" + node.right.startInterval + "-" + node.right.endInterval + "] and data: " + node.right.data; 
    } else {
      str = str + "No right child";
    }

    System.out.println(str + '\n');

    // call recursion
    if(node.left != null) {
      display(node.left);
    }

    if(node.right != null) {
      display(node.right);
    }
  }

  // query
  public int query(int qsi, int qei) {
    return this.query(this.root, qsi, qei);
  }
  private int query(Node node, int qsi, int qei) {
    if(node.startInterval >= qsi && node.endInterval <= qei) {
      // node is completely lying inside query
      return node.data;
    } else if (node.startInterval > qei || node.endInterval < qsi) {
      // completely outside
      return 0;
    } else {
      return this.query(node.left, qsi, qei) + this.query(node.right, qsi, qei);
    }
  }

  // update
  public void update(int index, int value) {
    this.root.data = update(this.root, index, value);
  }
  private int update(Node node, int index, int value) {
    if (index >= node.startInterval&& index <= node.endInterval){
      if(index == node.startInterval && index == node.endInterval) {
        node.data = value;
        return node.data;
      } else {
        int leftAns = update(node.left, index, value);
        int rightAns = update(node.right, index, value);
        node.data = leftAns + rightAns;
        return node.data;
      }
    }
    return node.data;
  }
  
}
-----------------------------------------------------------------
https://leetcode.com/problems/same-tree/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        return isSame(p,q);
    }
    public boolean isSame(TreeNode n1, TreeNode n2) {
        if(n1==null && n2==null){
            return true;
        }
        if(n1==null){
            return false;
        }
        if(n2==null){
            return false;
        }
        if(n1.val!=n2.val){
            return false;
        }
        return isSame(n1.left, n2.left) && isSame(n1.right, n2.right);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/symmetric-tree/ imp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root==null || isSymmetricHelp(root.left, root.right);
    }

    private boolean isSymmetricHelp(TreeNode left, TreeNode right){
        if(left==null || right==null)
            return left==right;
        if(left.val!=right.val)
            return false;
        return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/maximum-depth-of-binary-tree/ - can also be called diameter of tree (imp)
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        // Base case...
        // If the subtree is empty i.e. root is NULL, return depth as 0...
        if(root == null)  return 0;
        // if root is not NULL, call the same function recursively for its left child and right child...
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        // When the two child function return its depth...
        // Pick the maximum out of these two subtrees and return this value after adding 1 to it...
        return Math.max(leftDepth, rightDepth) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/balanced-binary-tree/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        // Call the dfsHeight function to get the height of the tree
        // If the returned value is -1, the tree is not balanced
        // Otherwise, it is balanced
        return dfsHeight(root) != -1;
    }
    public static int dfsHeight(TreeNode root){

        // Base case: If the root is null, the height is 0
        if(root == null){
            return 0;
        }
    
        // Recursively get the height of the left subtree
        int leftHeight = dfsHeight(root.left);

        // If the left subtree is not balanced, return -1
        if(leftHeight == -1){
            return -1;
        }
    
        // Recursively get the height of the right subtree
        int rightHeight = dfsHeight(root.right);
        
        // If the right subtree is not balanced, return -1
        if(rightHeight == -1){
            return -1;
        }
    
        // If the absolute difference between the left and right subtree heights
        // is greater than 1, the tree is not balanced, so return -1
        if(Math.abs(leftHeight - rightHeight) > 1){
            return -1;
        }
    
        // Otherwise, return the maximum height of the left and right subtrees, plus 1
        // This represents the height of the current node
    return Math.max(leftHeight,rightHeight)+1;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/minimum-depth-of-binary-tree/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        //base case
       if (root == null)
            return 0;
		//if there is only right child get depth of it
        if (root.left == null)
            return minDepth(root.right) + 1;
		//similarly if there is only left child  get depth of it
        else if (root.right == null)
            return minDepth(root.left) + 1;
		//in case there are both  get the min of both
        return Math.min(minDepth(root.right), minDepth(root.left)) + 1; 
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/binary-tree-preorder-traversal/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
       List<Integer> ret = new ArrayList<>();
        dfs(root, ret);
        return ret; 
    }
    private void dfs(TreeNode root, List<Integer> ret) {
        if (root != null) {
            ret.add(root.val);
            dfs(root.left, ret);
            dfs(root.right, ret);
        }
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/binary-tree-postorder-traversal/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ret = new ArrayList<>();
        dfs(root, ret);
        return ret;
    }
    private void dfs(TreeNode root, List<Integer> ret) {
        if (root != null) {
            dfs(root.left, ret);
            dfs(root.right, ret);
            ret.add(root.val);
        }
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/path-sum/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root==null)return false;
        sum = sum - root.val;
        if(root.left==null && root.right==null){
            if(sum == 0)return true;
            else return false;
        }
        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/sum-of-left-leaves/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum=0;
    public int sumOfLeftLeaves(TreeNode root) { 
        helper(root,false);
        return sum;
    }
    public void helper(TreeNode root,boolean isLeft)
    {
        if(root==null ) return;    
        if(root.left==null && root.right==null)
        {
            if(isLeft)
            sum+=root.val;
        }
        helper(root.left,true);
        helper(root.right,false);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/minimum-absolute-difference-in-bst/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
       TreeNode prev;
        int min = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        inorder(root);
        return min;
    }
    public void inorder(TreeNode root){
        if(root == null) return;

        inorder(root.left);
        if(prev != null) min = Math.min(min, root.val - prev.val);
        prev = root;
        inorder(root.right);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/binary-tree-paths/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> answer = new ArrayList<String>();
        if (root != null) searchBT(root, "", answer);
        return answer;
    }
    private void searchBT(TreeNode root, String path, List<String> answer) {
        if (root.left == null && root.right == null) answer.add(path + root.val);
        if (root.left != null) searchBT(root.left, path + root.val + "->", answer);
        if (root.right != null) searchBT(root.right, path + root.val + "->", answer);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/find-mode-in-binary-search-tree/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Integer prev=null;
    int count=1;
    int max=0;
    public int[] findMode(TreeNode root) {
        if(root==null){
            return new int []{};
        }
        ArrayList<Integer> nums=new ArrayList<>();
        getNodes(root,nums);
        int temp[]=new int [nums.size()];
        for(int i=0;i<nums.size();i++){
            temp[i]=nums.get(i);
        }
        return temp;
    }
    public void getNodes(TreeNode root,ArrayList<Integer> nums){
        if(root==null) return;
        getNodes(root.left,nums);
        if(prev!=null){
            if(prev==root.val) count++;
            else count=1;
        }
        if(count>max){
            nums.clear();
            max=count;
            nums.add(root.val);
        }
        else if(count==max){
            nums.add(root.val);
        }
        prev=root.val;
        getNodes(root.right,nums);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/invert-binary-tree/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        // Base case: if the tree is empty...
        if(root == null){
            return root;
        }
        // Call the function recursively for the left subtree...
        invertTree(root.left);
        // Call the function recursively for the right subtree...
        invertTree(root.right);
        // Swapping process...
        TreeNode curr = root.left;
        root.left = root.right;
        root.right = curr;
        return root;       
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/binary-tree-level-order-traversal/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int levelSize = queue.size();
            List<Integer> CurrentLevel = new ArrayList<>(levelSize);
            for (int i = 0; i<levelSize; i++){
                TreeNode currentNode = queue.poll();
                CurrentLevel.add(currentNode.val);
                if (currentNode.left != null) {
                    queue.offer(currentNode.left);
                }
                if (currentNode.right != null) {
                    queue.offer(currentNode.right);
                }
            }
            result.add(CurrentLevel);
        }
        return result;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/path-sum-ii/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> paths = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    helper(root, targetSum, path, paths);
    return paths;
  }
  public void helper(TreeNode node, int sum, List<Integer> path, List<List<Integer>> paths) {
    if(node == null) {
      return;
    }

    path.add(node.val);

    if (node.val == sum && node.left == null && node.right == null) {
      paths.add(new ArrayList<>(path));
    } else {
      helper(node.left, sum-node.val, path, paths);
      helper(node.right, sum-node.val, path, paths);
    }

    // backtrack
    path.remove(path.size() - 1);    
    }
}
-----------------------------------------------------------------
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
import java.util.AbstractMap;
class Solution {
    public List<List<Integer>> verticalTraversal(TreeNode node) {
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    if (node == null) {
      return ans;
    }

    int col = 0;

    Queue<Map.Entry<TreeNode, Integer>> queue = new ArrayDeque<>();
    Map<Integer, ArrayList<Integer>> map = new HashMap();

    queue.offer(new AbstractMap.SimpleEntry<>(node, col));

    int min = 0;
    int max = 0;

    while(!queue.isEmpty()) {
      Map.Entry<TreeNode, Integer> removed = queue.poll();
      node = removed.getKey();
      col = removed.getValue();

      if(node != null) {
        if(!map.containsKey(col)) {
          map.put(col, new ArrayList<Integer>());
        }

        map.get(col).add(node.val);

        min = Math.min(min, col);
        max = Math.max(max, col);

        queue.offer(new AbstractMap.SimpleEntry<>(node.left, col-1));
        queue.offer(new AbstractMap.SimpleEntry<>(node.right, col+1));
      }
    }

    for(int i=min; i <= max; i++) {
      ans.add(map.get(i));
    }

    return ans;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/word-ladder/
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet = new HashSet<String>(wordList);
        if( !wordSet.contains(endWord) )
        return 0;
	// 3. Use set instead of queue during bfs
    Set<String> forwardSet = new HashSet<String>(); 
    Set<String> backwardSet = new HashSet<String>();
    forwardSet.add(beginWord);
    backwardSet.add(endWord);
    wordSet.remove(endWord);
    wordSet.remove(beginWord);
	// 1. Search from entry and exit simultaneously
    return transform(forwardSet, backwardSet, wordSet);
}

public int transform(Set<String> forwardSet, Set<String> backwardSet, Set<String> wordSet) {
    Set<String> newSet = new HashSet<String>();
    for(String fs : forwardSet) {
        char wordArray[] = fs.toCharArray();
        for(int i = 0; i < wordArray.length; i++) {
            for(int c = 'a'; c <= 'z'; c++) {
                char origin = wordArray[i];
                wordArray[i] = (char) c;
                String target = String.valueOf(wordArray);
                if( backwardSet.contains(target) )
                    return 2; // stop bfs when entry and exits meet
                else if( wordSet.contains(target) && !forwardSet.contains(target) ) {
                    wordSet.remove(target); // 4. Remove visited word from wordList to decrease the search time
                    newSet.add(target);
                }
                wordArray[i] = origin;
            }
        }
    }
    if( newSet.size() == 0 )
        return 0;
    forwardSet = newSet;
	// 2. Pick the queue with less elements to bfs
    int result = forwardSet.size() > backwardSet.size() ? 
        transform(backwardSet, forwardSet, wordSet) : transform(forwardSet, backwardSet, wordSet);
    return result == 0 ? 0 : result + 1;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/linked-list-in-binary-tree/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSubPath(ListNode head, TreeNode root) {
        if(root == null)    return false;
        if(issame(head, root))  return true;
        return isSubPath(head, root.left) || isSubPath(head, root.right);
    }
    private boolean issame(ListNode head, TreeNode root) {
        if(head == null)    return true;
        if(root == null)    return false;
        if(head.val != root.val)    return false;
        return issame(head.next, root.left) || issame(head.next, root.right);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/path-sum-iii/solutions/4274495/beats-100-00-of-users-with-java-easy-dfs-code-o-n-tc-with-explanation/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // Map for keeping track of (PrefixSum, timesPrefixSumSeen) during traversal
    Map<Long, Integer> hmap;
    int count;

    public int pathSum(TreeNode root, int targetSum) {
        hmap = new HashMap<>();
        count = 0;

        dfs(root, 0, targetSum);

        return count;
    }

    private void dfs(TreeNode root, long prefixSum, int targetSum) {
        // base case
        if (root == null) return;

        
        prefixSum += root.val;
        
        // If map contains a sum equal to (prefixSum - targetSum), we need to increment count that many times
        if (hmap.containsKey(prefixSum-targetSum)) {
            count += hmap.get(prefixSum-targetSum);
        } 
        
        // There can be cases when the prefixSum is directly equal to targetSum, we need to increment count
        if (targetSum == prefixSum) {
            count++;
        }

        // Update the prefixSum till current node and it's count
        hmap.put(prefixSum, hmap.getOrDefault(prefixSum, 0) + 1);

        // Recurse
        dfs(root.left, prefixSum, targetSum);
        dfs(root.right, prefixSum, targetSum);

        // Backtrack
        hmap.put(prefixSum, hmap.get(prefixSum) - 1);
        
    }
}
-----------------------------------------------------------------
class Solution {
    Map<Integer, TreeNode> parents;

    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        parents = new HashMap<>();
        dfs(root,null);
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(target);
        int dist = 0;
        HashSet<TreeNode> visited = new HashSet<>();
        visited.add(target);
        while (!queue.isEmpty() && dist!=k){
            int size = queue.size();
            for(int i = 0;i<size;i++){
                TreeNode removed = queue.remove();
                if(removed.left!=null && !visited.contains(removed.left)) {
                    queue.add(removed.left);
                    visited.add(removed.left);
                }
                if(removed.right!=null && !visited.contains(removed.right)) {
                    queue.add(removed.right);
                    visited.add(removed.right);
                }
                if(parents.containsKey(removed.val) && !visited.contains(parents.get(removed.val))) {
                    queue.add(parents.get(removed.val));
                    visited.add(parents.get(removed.val));
                }
            }
            dist++;
        }
        List<Integer> ans = new ArrayList<>();
        while (!queue.isEmpty()){
            ans.add(queue.remove().val);
        }
        return ans;
    }

    public void dfs(TreeNode node, TreeNode parent){
        if(parent!=null){
            parents.put(node.val, parent);
        }
        if(node.left!=null) dfs(node.left,node);
        if(node.right!=null) dfs(node.right,node);
    }
}
-----------------------------------------------------------------
https://www.youtube.com/watch?v=myH6qdThNPY&t=497s
class Solution {
    Map<Integer, TreeNode> parents;

    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        parents = new HashMap<>();
        dfs(root,null);
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(target);
        int dist = 0;
        HashSet<TreeNode> visited = new HashSet<>();
        visited.add(target);
        while (!queue.isEmpty() && dist!=k){
            int size = queue.size();
            for(int i = 0;i<size;i++){
                TreeNode removed = queue.remove();
                if(removed.left!=null && !visited.contains(removed.left)) {
                    queue.add(removed.left);
                    visited.add(removed.left);
                }
                if(removed.right!=null && !visited.contains(removed.right)) {
                    queue.add(removed.right);
                    visited.add(removed.right);
                }
                if(parents.containsKey(removed.val) && !visited.contains(parents.get(removed.val))) {
                    queue.add(parents.get(removed.val));
                    visited.add(parents.get(removed.val));
                }
            }
            dist++;
        }
        List<Integer> ans = new ArrayList<>();
        while (!queue.isEmpty()){
            ans.add(queue.remove().val);
        }
        return ans;
    }

    public void dfs(TreeNode node, TreeNode parent){
        if(parent!=null){
            parents.put(node.val, parent);
        }
        if(node.left!=null) dfs(node.left,node);
        if(node.right!=null) dfs(node.right,node);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/validate-binary-tree-nodes/
class Solution {
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        
        Deque<Integer> queue = new ArrayDeque<>();
        
        Set<Integer> visited = new HashSet<>();
        int root = findRoot(n, leftChild, rightChild);
        if (root == -1) return false;
        
        queue.offer(root);
        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (node == -1) continue;
            
            if (!visited.add(node)) return false;
            
            int left = leftChild[node];
            int right = rightChild[node];
            
            queue.offer(left);
            queue.offer(right);
        }
        
        return visited.size() == n;
    }
    
    private int findRoot(int n, int[] left, int[] right) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) set.add(i);
        for (int node : left) set.remove(node);
        for (int node : right) set.remove(node);
        
        return set.size() == 1 ? set.iterator().next() : -1;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/longest-univalue-path/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int min = Integer.MIN_VALUE;
    public int longestUnivaluePath(TreeNode root) {
        if(root ==null)
            return 0;
        dfs(root,root.val);
        return min;
    }
    public int dfs(TreeNode root, int prevVal){
        if( root == null){
            return 0;
        }
        int left=dfs(root.left,root.val);
        int right=dfs(root.right,root.val);
        min = Math.max(min, left+right);
        if(root.val==prevVal){
            return Math.max(left,right)+1;
        }
        return 0;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/ important
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> nodes = new ArrayList<>(); 
    void traverse(TreeNode root) {
        if (root == null) return;
        
        traverse(root.left);
        nodes.add(root.val);
        traverse(root.right);
    }
    
    List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {
        traverse(root);                         // traverse all nodes and store them in ArrayList
        
        List<List<Integer>> ans = new ArrayList<>();
        int n = nodes.size();
        
        for (int q : queries) {            
            if (q == nodes.get(0) || q == nodes.get(n-1)) {           // if value is already found, no need to do BS
            	ans.add(Arrays.asList(q, q));
            }
            else if (q < nodes.get(0)) {
            	ans.add(Arrays.asList(-1, nodes.get(0)));             // if value == first element, no need to do BS
            }
            else if (q > nodes.get(n-1)) {
            	ans.add(Arrays.asList(nodes.get(n-1), -1));          // if value == last element, no need to do BS
            }
            else {
            	int lo = 0;
            	int hi = n-1;
            	boolean found = false;
            	while (lo < hi) {
            		int m = (lo+hi) >> 1;
            		int mid = nodes.get(m);
            		if (q == mid) {
            			found = true;
            			ans.add(Arrays.asList(q, q));
            			break;
            		}
            		else if (q > mid) {
            			lo = m + 1;
            		}
            		else {
            			hi = m;
            		}
            	}
            	
				// now lo and hi are equal
            	if (!found) {
            		ans.add(Arrays.asList(nodes.get(lo-1), nodes.get(lo)));
            	}
            }
        }
        
        return ans;
    } 
}
-----------------------------------------------------------------
https://leetcode.com/problems/maximum-width-of-binary-tree/
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        
        int maxWidth = 1;
        Queue<TreeNode> queue = new LinkedList<>();
        Queue<Integer> indexQueue = new LinkedList<>();
        queue.offer(root);
        indexQueue.offer(1);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            int leftIndex = 0, rightIndex = 0;
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                int index = indexQueue.poll();
                
                if (i == 0) {
                    leftIndex = index;
                }
                if (i == levelSize - 1) {
                    rightIndex = index;
                }
                
                if (node.left != null) {
                    queue.offer(node.left);
                    indexQueue.offer(index * 2);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                    indexQueue.offer(index * 2 + 1);
                }
            }
            
            maxWidth = Math.max(maxWidth, rightIndex - leftIndex + 1);
        }
        
        return maxWidth;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public long kthLargestLevelSum(TreeNode root, int k) {
        if(root == null){
            return -1;
        }
        Queue<TreeNode> q= new LinkedList<>();
        q.add(root);
        ArrayList<Long> list = new ArrayList<>();

        while(!q.isEmpty()){
            int size=q.size();
            long sum = 0;
            for(int i = 0;i<size;i++){
                TreeNode temp = q.remove();
                sum += temp.val;
                if(temp.left != null) {
                    q.add(temp.left);
                }
                if(temp.right != null) {
                    q.add(temp.right);
                }
            }
            list.add(sum);
        }
        
        if(k > list.size()){
            return -1;
        }
        Collections.sort(list);
        
        return list.get(list.size() - k);
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/
class Solution {
    public boolean isValidSerialization(String preorder) {
        String[] nodes = preorder.split(",");
    int diff = 1;
    for (String node: nodes) {
        if (--diff < 0) return false;
        if (!node.equals("#")) diff += 2;
    }
    return diff == 0;
    }
}x
-----------------------------------------------------------------
https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    ArrayList<Long> list=new ArrayList<>();
    public int maxProduct(TreeNode root) 
    {
        long total=total(root);
        long max=0,mod=(int)(1e9 + 7);
        for(int i=0;i<list.size();i++)
        {
            max=Math.max(max,(total-list.get(i))*list.get(i));
        }
        return (int)(max%(mod+7));
    }
    public long total(TreeNode node)
    {
        if(node==null) return 0;
        long left=total(node.left);
        long right=total(node.right);
        long subsum=left+right+node.val;
        list.add(subsum);
        return subsum;
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int vix = 0;
    List<Integer> ans = new ArrayList<>();
    private void dfs(TreeNode node, int[] voyage) {
      if (node == null || (ans.size() != 0 && ans.get(0) == -1)) return;
        if (node.val != voyage[vix++])
            ans = new ArrayList<Integer>(Arrays.asList(-1));
        else if (node.left != null && node.left.val != voyage[vix]) {
            ans.add(node.val);
            dfs(node.right, voyage);
            dfs(node.left, voyage);
        } else {
            dfs(node.left, voyage);
            dfs(node.right, voyage);
        }
    }
    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {
        dfs(root, voyage);
        return ans;  
    }
}
-----------------------------------------------------------------
https://leetcode.com/problems/count-nodes-with-the-highest-score/
class Solution {
    class TreeNode {
		private TreeNode left;
		private TreeNode right;
		private long score = 0L;
		private int nodeCount = 0;

	}

	private int countNodes (TreeNode root) { // post order traversal
		if (root == null) {
			return 0;
		}
		root.nodeCount = countNodes(root.left) + countNodes(root.right) + 1;

		return root.nodeCount;
	}


	public int countHighestScoreNodes(int[] parents) {
		long max = 0l;

		int n = parents.length;
		int ans = 0;
		TreeNode[] tree = new TreeNode[n];

		for (int i = 0; i < parents.length; i++) {
			tree[i] = new TreeNode();
		}

		for (int i = 1; i < parents.length; i++) {
			int parentId = parents[i];
			if (tree[parentId].left == null) {
				tree[parentId].left = tree[i];
			} else {
				tree[parentId].right = tree[i];
			}
		}

		countNodes(tree[0]);


		for (int i = 0; i < parents.length; i++) {
			long product = 1;
			int leftCnt = tree[i].left == null ? 0 : tree[i].left.nodeCount;
			int rightCnt = tree[i].right == null ? 0 : tree[i].right.nodeCount;
			int parentCnt = n - 1 - leftCnt - rightCnt;

			if (leftCnt > 0) {
				product *= leftCnt;
			}
			if (rightCnt > 0) {
				product *= rightCnt;
			}
			if (parentCnt > 0) {
				product *= parentCnt;
			}
			tree[i].score = product;
			max = Math.max(max, product);
		}

		//count nodes
		for (int i = 0; i < parents.length; i++) {
			if (tree[i].score == max) {
				ans++;
			}
		}
		return ans;
	}
}
-----------------------------------------------------------------
https://leetcode.com/problems/operations-on-tree/
class LockingTree {
    int[] parent;
    int[] locked;
    ArrayList<Integer>[] child;
    public LockingTree(int[] parent) {
        this.parent=parent;
        this.locked=new int[parent.length];
        this.child = new ArrayList[parent.length];

        for(int i=0;i<child.length;i++){
            child[i] = new ArrayList<>();
        }

        for(int i=1;i<parent.length;i++){
            child[parent[i]].add(i);
        }
    }
    
    public boolean lock(int num, int user) {
        if(locked[num]==0){
            locked[num]=user;
            return true;
        }
        return false;
    }
    
    public boolean unlock(int num, int user) {
        if(locked[num]==user){
            locked[num]=0;
            return true;
        }
        return false;
    }
    
    public boolean upgrade(int num, int user) {
        if(locked[num]!=0){
            return false;
        }
        int ancestor = parent[num];
        while(ancestor!=-1){
            if(locked[ancestor]!=0){
                return false;
            }
            ancestor = parent[ancestor];
        }
        if(!hasLockedDescendant(num)){
            return false;
        }
        else{
            unlockAll(num);
            locked[num]=user;
            return true;
        }
    }
    private boolean hasLockedDescendant(int num){
        if(locked[num]!=0){
            return true;
        }
        for(int x:child[num]){
            if(hasLockedDescendant(x)){
                return true;
            }
        }
        return false;
    }
    private void unlockAll(int num){
        locked[num]=0;
        for(int x:child[num]){
            unlockAll(x);
        }
    }
}

/**
 * Your LockingTree object will be instantiated and called as such:
 * LockingTree obj = new LockingTree(parent);
 * boolean param_1 = obj.lock(num,user);
 * boolean param_2 = obj.unlock(num,user);
 * boolean param_3 = obj.upgrade(num,user);
 */
-----------------------------------------------------------------
Advanced Questions:
-----------------------------------------------------------------
class PreIn {

  public TreeNode buildTree(int[] preOrder, int[] inOrder) {
    HashMap<Integer, Integer> map = new HashMap<>();

    for(int i=0; i < inOrder.length; i++) {
      map.put(inOrder[i], i);
    }

    int[] index = {0};
    
    return helper(preOrder, inOrder, 0, preOrder.length-1, map, index);
  }

  public TreeNode helper(int[] preOrder, int[] inOrder, int left, int right, HashMap<Integer, Integer> map, int[] index) {
    if (left > right) {
      return null;
    }

    int current = preOrder[index[0]];
    index[0]++;

    TreeNode node = new TreeNode(current);

    if (left == right) {
      return node;
    }

    node.left = helper(preOrder, inOrder, left, index - 1, map, index);
    node.right = helper(preOrder, inOrder, index + 1, right, map, index);

    return node;
  }
}
-----------------------------------------------------------------
class VerticalTraversal {
  public List<List<Integer>> verticalTraversal(TreeNode node) {
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    if (node == null) {
      return ans;
    }

    int col = 0;

    Queue<Map.Entry<TreeNode, Integer>> queue = new ArrayDeque<>();
    Map<Integer, ArrayList<Integer>> map = new HashMap();

    queue.offer(new AbstractMap.SimpleEntry<>(node, col));

    int min = 0;
    int max = 0;

    while(!queue.isEmpty()) {
      Map.Entry<TreeNode, Integer> removed = queue.poll();
      node = removed.getKey();
      col = removed.getValue();

      if(node != null) {
        if(!map.containsKey(col)) {
          map.put(col, new ArrayList<Integer>());
        }

        map.get(col).add(node.val);

        min = Math.min(min, col);
        max = Math.max(max, col);

        queue.offer(new AbstractMap.SimpleEntry<>(node.left, col-1));
        queue.offer(new AbstractMap.SimpleEntry<>(node.right, col+1));
      }
    }

    for(int i=min; i <= max; i++) {
      ans.add(map.get(i));
    }

    return ans;
  }
}
-----------------------------------------------------------------
public class WordLadder {
    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord))
            return 0;

        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
        q.offer(beginWord);
        int length = 0;

        while (!q.isEmpty()) {
            int size = q.size();
            length++;

            for (int i = 0; i < size; i++) {
                String current = q.poll();

                for (int j = 0; j < current.length(); j++) {
                    char[] temp = current.toCharArray();

                    for (char c = 'a'; c <= 'z'; c++) {
                        temp[j] = c;
                        String newWord = new String(temp);

                        if (newWord.equals(endWord))
                            return length + 1;

                        if (wordList.contains(newWord) && !visited.contains(newWord)) {
                            q.offer(newWord);
                            visited.add(newWord);
                        }
                    }
                }
            }
        }

        return 0;
    }
}
-----------------------------------------------------------------
class TwoSum {
  public boolean findTarget(TreeNode root, int k) {
    HashSet<Integer> set = new HashSet<>();
    return helper(root, k, set);
  }
  private boolean helper(TreeNode node, int k, HashSet<Integer> set) {
    if(node == null) {
      return false;
    }
    if(set.contains(k - node.val)) {
      return true;
    }

    set.add(node.val);
    return helper(node.left, k, set) || helper(node.right, k , set);
  }
}
-----------------------------------------------------------------
class KthSmallest {
  public int kthSmallest(TreeNode root, int k) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    helper(root, minHeap, k);

    // remove k elements
    int ans = 0;
    for(int i=0; i<k; i++) {
      ans = minHeap.poll();
    }
    return ans;
  }

  private void helper(TreeNode node, PriorityQueue<Integer> minHeap, int k) {
    if (node == null) {
      return;
    }

    helper(node.left, minHeap, k);

    minHeap.offer(node.val);
    
    helper(node.right, minHeap, k);
  }
}
-----------------------------------------------------------------
class KthSmallest {
  private int k;
  private int ans;
  
  public int kthSmallest(TreeNode root, int k) {
    this.k = k;
    helper(root);
    return ans;
  }

  private void helper(TreeNode node) {
    if (node == null) {
      return;
    }

    helper(node.left);

    k--;
    if(k==0) {
      ans = node.val;
      return;
    }
    
    helper(node.right);
  }
}
-----------------------------------------------------------------
public class DoubleLinkedList {
  LLNode head;
  LLNode tail;

  public TreeNode convert(TreeNode root) {
    if (root == null) {
      return null;
    }

    helper(root);

    return head;
  }

  private void helper(TreeNode node) {
    if(node == null) {
      return null;
    }

    helper(node.left);


    LLNode newNode = new LLNode(node.val);

    if(head == null) {
      head = newNode;
      tail = newNode;
    } else {
      tail.next = newNode;
      newNode.prev = tail;
      tail = newNode;
    }
    
    helper(node.right);
    
  }
}

class LLNode {
  int val;
  LLNode prev;
  LLNode next;

  public LLNode (int val) {
    this.val = val;
  }
}

class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  public TreeNode (int val) {
    this.val = val;
  }
}
-----------------------------------------------------------------
import java.util.*;

class Node {
  int val;
  Node left; 
  Node right;
  public Node (int val) {
    this.val = val;
  }
}

public class TwoNodeSwap {
  Node first;
  Node second;
  Node prev;

  public void helper(Node root) {
    iot(root);

    // swap
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
  }

  private void iot(Node node) {
    if(node == null) {
      return;
    }

    iot(node.left);

    if(prev != null && prev.val > node.val) {
      if(first == null) {
        first = prev;
      }
      second = node;
    }

    prev = node;
    
    iot(node.right);
  }

  public void printIOT(Node node) {
    if(node == null) {
      return;
    }
    printIOT(node.left);
    System.out.print(node.val + " ");
    printIOT(node.right);
  }
}
-----------------------------------------------------------------
